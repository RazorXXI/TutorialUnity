# Capítulo 13 - Aspectos Avanzados de programacion C#

 En este punto nos vamos a centrar en ciertas cosas que aun no hemos visto y que van a resultarnos útiles a la hora de desarrollar nuestros juegos o aplicaciones en Unity.

 Advierto desde ya, que este capítulo va a ser muy denso y bastante tocho, pero es que no podia hacerlo de otra forma, así que ponte cómodo, pilla cafe, coca cola o lo que quieras beber, unas patatas, que vamos a meternos en faena.

## Clases Estáticas

 Una clase estática es aquella en la que sus variables y métodos, que indiquemos como estáticos, compartirán los datos que almacenen en todas las instancias de esa clase. 

 Sé que la chapa que te he soltado antes te ha dejado igual, así que voy a explicarlo mejor, fuera de su definición _"oficial"_.

 Pensemos en lo siguiente. Cuando instanciamos un objeto de una clase, este tendrá sus valores de variables y métodos según lo modifiquemos en su instancia, y si instanciamos otro objeto, este último, tendrá otros valores... Hasta aquí todo correcto. Pero, si una variable de la clase es marcada como __static__, todas las instancias que creemos de esa clase, cuando modifiquemos la variable _estatica_, esta tendrá el mismo valor en el resto de instancias, durante toda la ejecución del programa.

 Para que entendamos lo anterior, diremos que los atributos de una clase, no van a representar valores de una instancia, sino que directamente va a representar a la clase.

 Y tu preguntaras, como accedo al atributo o método estático de un objeto de una clase... pues muy simple, simplemente nombrando a la clase en cuestion (__OJO: NO AL OBJETO...__) seguida de punto y el nombre del atributo o el método.

 Ya puesto, estaras preguntando como se declara un atributo o un método como estático... o no?? Bueno, si no te lo preguntas, yo te lo cuento. La manera de declarar un atributo o un método como estático, es básicamente incluyendo la palabra `static`. Te pongo un ejemplito para que lo veas mas claro.

 ```c#
public class Bullet
{
  public static int cuentaBullets = 0; //Atributo estatico
  public Bullet()
  {
    cuantaBullet++;
  }
}

public class PruebaBullet:MonoBehaviour
{
  void Start()
  {
    //Cada vez que creo un objeto de la clase Bullet, en esta se incrementa
    //la variable cuentaBullet.
    Bullet bullet01 = new Bullet();
    Bullet bullet02 = new Bullet();
    Bullet bullet03 = new Bullet():
  }

  //Aqui asignamos el valor de cuentaBullet a una variable
  //Observar que llamamos a la clase y no a uno de los objetos creado.
  int numeroBullets = Bullet.cuentaBullet;

  Debug.Log(numeroBullets);
}
 ```

 El ejemplo que hemos visto, es para ir creando objetos a partir de la clase, pero por ejemplo, supongamos que voy a crear objetos, arrastrando su `prefab`.

 En ese caso, debemos incluir la clase `Bullet` como componente del _GameObject_ en cuestión y en ese caso, la clase __Bullet__ si deberá heredar de `MonoBehaviour`.

 ```c#
class Bullet : MonoBehaviour
{
  public static int cuentaBullet = 0;

  void Start()
  {
    cuentaBullet++;
    Debug.Lot(cuentaBullet);
  }
}
 ```

 Como hemos dicho, podemos declarar además de variables, métodos estáticos, los cuales serán métodos de la clase propiamente y no de las instancias de esta.

 A continuación vamos a poner un ejemplo de como sería un método estático.

 Vamos a suponer que pertenece a la clase `Bullet` del ejemplo anterior.
 ```c#
 public static void demasiadasBalas()
 {
  if(cuentaBullet > 10)
  {
    Debug.Log("Demasiadas Balas...");
  }
 }
 ```

 Si quisieramos llamar este método desde cualquier otra clase, deberiamos hacerlo de la siguiente manera:

 ```c#
 Bullet.demasiadasBalas();
 ```

 Si por ejemplo ejemplo queremos comprobar si se han disparados demasiadas balas, pondriamos la instrucción anterior dentro del método `Update()`.

 Una cosa muy importante a tener en cuenta, es que no podemos usar métodos "*normales*" o de instancias en los métodos estaticos, ya que generarian un conflicto, ya que los primeros son **valores de la clase** y los últimos son **especificos de cada objeto**.

 Antes de terminar con este punto, voy a haceros una consideración y es que, es posible crear **clases estáticas**. 

 Una **clase estática** es muy útil, si queremos realizar una clase compuesta únicamente por **atributos y métodos estaticos**, cuya finalidad no sea la creación de instancias u objetos.

 Un ejemplo muy típico en Unity de clase estatica es la `clase input` o algunas clases matemáticas como `mathf`.

## Constantes

 Las constantes son datos los cuales no van a variar su valor durante la ejecución de nuestro código, al contrario que sucede con las variables.

 La forma de declarar una variables es la siguiente:

 ```
 modificador_de_acceso const tipo_dato identificador = valor_asignado;
 ```

 Si lo vemos con un ejemplo lo veremos mas claro.

 ```c#
 public const float PI = 3.14f;
 ```

 En algunos lenguajes de programación se suele poner el identificador todo en mayuscula, pero para no liarnos usaremos la misma nomenclatura que para la declaración de varibles, aunque si tu prefieres poner el identificador en mayusculas todo, no te va a dar fallo el compilador.

 Las tres razones principales para el uso de las variables son:


  * __Facilidad de Lectura:__ Si alguien ajeno a nosotros tiene que modificar nuestro código, rapidamente podrá identificar que el valor declarado como constante, será inamovible.
  * __Optimización:__ El compilador reservará una cierta cantidad de memoria durante toda la ejecución de nuestro programa, permitiendo centrar recursos en otros procesos.
  * __Seguridad:__ Al no poderse modificar su valor en tiempo de ejecución, evitaremos cambiar dicho valor por error durante la ejecución o bien por equivocación mientras escribimos el código, ya que el compilador nos informará de un error informando que estamos tratando de cambiar el valor de una constante.

## Enumeraciones

 Las enumeraciones son un tipo de variable la cual poseera un conjunto de valores constantes.

 Sé que ahora no queda muy claro, pero en breve lo pillaras rápido.

 Las enumeraciones se pueden declarar fuera o dentro de la clase, pero para seguir un orden, nosotros las declararemos dentro de la clase que estemos creando.

 La forma de declarar una enumeración será del siguiente modo:

  1 - _**Modificador de Acceso**_: 'public' o 'private'.

  2 - _**Palabra reservada**_: 'enum'.

  3 - _**Identificador de la enumeración**_: 'NumeroDeJugadores'.

  4 - _**Constantes separadas por comas y entre llaves**_: '{onePlayer, twoPlayers, noPlayers}

 Con un ejemplo lo veremos mas claro:

  ```c#
  public enum NumeroDeJugadores {onePlayer, twoPlayers, noPlayers};
  ```

 Una cosa importante a la hora de declarar una enumeración, es comenzar su identificador en mayúsculas, a fin de respetar las reglas de estilo. Y si te preguntas porque esto es así... pues sencillo, **NO ESTAMOS DECLARANDO UNA VARIABLE**, estamos declarando un tipo de dato.

 Vamos a ver otro ejemplo.

 ```c#
 public enum ObjetosInventario { Money, Food, Health, Weapon, Magic };
 ```

Todas las constantes declaradas dentro de la enumeración (*Money, Food, Health, Weapon, Magic*) tendran un valor asignado por defecto, que será un número entero, el cual comenzará por 0. Este valor se irá incrementando en 1 de izquierda a derecha (como en los indices de los arrays).

Según lo anterior, *Money* tendrá el valor 0, *Food* el valor 1 y así sucesivamente.

Por supuesto, estos valores se pueden modificar, si por ejemplo a *Money* le asignamos el valor 1, *Food* por defecto pasará a tomar el valor 2 y el resto de constantes, se verán incrementadas igualmente en 1.

Una manera común entre los programadores, es colocar las enumeraciones del siguiente modo.

```c#
 public enum ObjetosInventario {
  Money = 1,
  Food,
  Health,
  Weapon,
  Magic
 };
```

 Esta forma vista no es obligatoria, pero la mayoria de programadores la usan, asi que es aconsejable a que te acostumbres a usarla, para que tu código se vea como un autentico *"pofesional"*.

 Otro dato que te tengo que contar es que podemos asignar las constantes de la enumeración, los valores que queramos. Y para muestra un botón.

 ```c#
 public enum ObjetosInventario {
  Money = 50,
  Food = 10,
  Health = 20,
  Weapon = 15,
  Magic = 5
 };
```

 Bueno, si te estas preguntando como usar la enumeración una vez que la tengas declarada, pues facil, como cualquier otro tipo de dato.

 ```c#
 private ObjetosInventario objeto;
 ```
 Por defecto, `objeto` será `Money`, aunque también podemos asignarle en la declaración o en cualquier otro momento que queramos, un valor diferente entre los que tengamos en la enumeración, puesto que `objeto` es una variable de tipo `ObjetosInventario`.

 Te lo enseño mejor con un ejemplito bueno.

 ```c#
 private ObjetosInventario objeto = ObjetosInventario.Health;
 ```

 Mira que fácil.

 Por supuesto, también podemos hacer comparaciones con la variable o hacer asignaciones numéricas de tipo entera, usando el valor numérico asignado para el valor de la variable tipo `enum`.

 Con un ejemplo lo vamos a entender mejor.

 ```c#
 void functionWhatever()
 {
    if((int)objeto == 0)
    {
       /*
        Si suponemos que tenemos los valores por defecto 0, 1, 2, 3.
        si el valor de objeto fuera 0, el cual corresponde a Money, se ejecutarian las 
        instrucciones dentro de la condición.
       */
    }
 }
```

Bueno y ahora vamos a ver dos maneras de cambiar el valor asignado a las constantes de la enumeración.

 ```c#
 void funcionCualquiera()
 {
    //Forma 1
    objeto = ObjetosInventario.Weapon;

    //Forma 2
    objeto = (ObjetosInventario)3; //Tambien elegiria Weapon, el cual estaba numerado inicialmente como 3, numerados de 0 a n-1
 }
 ```

 ## Máquina de Estados

 Una máquina de estados, no es el gobierno ese que los mas conspiranoicos dice que controlan a los paises en la sobra, no... quizas eso sería mas divertido, pero no es es el caso. En fin, que me voy por las ramas.

 Una __máquina de estados__ es una función que se emplea para **controlar el código en tiempo de ejecución**.

 A ver, seguro que estas preguntando, eso no lo hace el compilador?? - Respuesta: NO, ESTO ES OTRA COSA.

 El uso de `máquina de estados` está muy extendido, esto se debe a su buena estructuración y a su capacidad de separar acciones de forma ordenada, de manera que facilita el entendimiento para futuras depuraciones o ampliación del código.

 Y tu te estarás diciendo <SI, TODO ESO ESTA MUY BIEN, PERO PARA EN VIDEOJUEGOS PARA QUE LA PUEDO USAR??>. Bueno, tranqui tronco, que ahí quiero llegar.

 En videojuegos, la máquina de estados, es usa por norma general para __crear una inteligencia artificial de enemigos o para personajes secundarios__. Si! vamos a crear a SkyNet... (_en realidad no... no lo flipes tan pronto_).

 Vamos a ver como podemos implementar una máquina de estados sencillita, y pares vamos a poner un ejemplito to´ guapo de esos que te pongo.

---
 ### Estructura de Una Máquina de Estados

 La máquina de estados que vamos a crear, básicamente tendrá la siguiente forma:


 ![Maquina de estados](../img/12_02_State_machine.png)

 Este será el diagrama de estados que vamos a realizar. Facilito y sin pretensiones.

 Para que lo entiendas mas claro, te voy a explicar que vamos a hacer. Nuestra máquina de estados estará destinada a un NPC, el cual estará parado en reposo, que puede pasar a un estado de hablar o a escuchar.

 Pues bien, para crear la maquina de estados, tendremos primero que crear un _script_ que representará a la máquina de estados, y tantos _scripts_ como los estados que hemos definido. En resumen, deberemos crear los siguiente scripts:

 * `NPCStatesMachine.cs`
 * `NPCIdleState.cs`
 * `NPCTalkState.cs`
 * `NPCHearState.cs`
 * `NPCFinishTalkState.cs`

 Cada uno de estos scripts, deberán ser añadidos como componentes dentro de nuestros NPC's (__"Non Player Controller"__ personajes dentro del juego que no son controlables, vamos los secundarios que estan por ahí dentro del juego), bien dentro de un GameObject de la escena o en un __prefab__, por si lo queremos instanciar en tiempo de ejecución.

 Bueno, vamos al lio. Vamos a centrarnos en el primer script, en el de la máquina de estados propiamente dicho. Aquí debemos incluir el resto de scripts como variables de clase, pero en lugar de asignarles su propio tipo, vamos a asignarles el de la clase padre __MonoBehaviour__. Esto es necesario, para que los scripts puedan ser tratados como componentes de un _GameObject_ de Unity.

 Lo siguiente que vamos a hacer, es crear __dos nuevas variables__, también de la clase _MonoBehaviour_, en el script de __NPCStateMachine.cs__. La primera variable la llamaremos __NPCActualState__, y la segunda __NPCFirstState__. Estas dos variables no servirán para indicar el estado actual e inicial del NPC. De estar forma, el primero de estos dos nuevos _scripts_ irá cambiando a medida que el juego se vaya desarrollando, mientras que el NPC interactuará con el objeto _Player_ que será el que nosotros controlemos.

 En fin, la cabecera del script, nos quedaria de momento así:

 ```c#
  public class NPCStateMachine : MonoBehaviour
  {
     public MonoBehaviour NPCIdleState; 
     public MonoBehaviour NPCTalkState;
     public MonoBehaviour NPCHearState;
     public MonoBehaviour NPCFinishTalkState;
     MonoBehaviour NPCActualState;
     public NPCFirstState;

     ...
  }
 ```

 El motivo de que las cuatro variables iniciales asi como las dos nuevas sean de tipo _MonoBehaviour_, se basa en que estas dos últimas no están relacionadas con los scripts que hemos creado, asi que adoptarán temporalmente el valor de las primeras, dicho de otra forma, `NPCActualState` a veces tomará el valor de `NPCIdleState`, `NPCTalkState`, etc... Por otro lado, la variable `NPCActualState` deberà ser privada, para evitar acceder a ella de manera accidental desde una clase distinta.

 La forma en la que quedaría el conjunto de componentes del NPC, sería la siguiente:

 ![StateMachine Inspector](../img/12_02_State_machine_Inspector.png)

 Ahora vamos a crear una función pública en el script de `NPCStateMachine`, que se encargarà de gestionar o modificar el estado actual del personaje. Esta función será públic para que sea accesible desde las clases externas a la declarada, y además, se ingresará desde los _scripts_ que estamos mencionando y que coinciden con los estados que hemos indicado.

 Por tanto, nuestra clase `NPCStateMachine` quedará del siguiente modo:

 ```c#
  public class NPCStateMachine : MonoBehaviour
  {
     public MonoBehaviour NPCIdleState; 
     public MonoBehaviour NPCTalkState;
     public MonoBehaviour NPCHearState;
     public MonoBehaviour NPCFinishTalkState;
     MonoBehaviour NPCActualState;
     public MonoBehaviour NPCFirstState;

     public void ChangeState(MonoBehaviour newState)
     {
       if(NPCActualState != null)
       {
         NPCActualState.enabled = false;
       }
       NPCActualState = newState;
       NPCActualState.enabled = true;
     }
  }
 ``` 

 La finalidad de la función es, cambiar de estado cuando así lo indiquemos mediante un parámetro de entrada que será asignado a la variable `NPCActualState`, activando dicho componente tras desactivar el anterior. La condición del `if` servirá para la ejecución inicial, ya que al no poseer `NPCActualState` ningún valor, obtendríamos un error.

 Por si no queda claro aun como va todo esto, vamos a ver un ejemplo para entender todo este sistema, lo que viene siendo, como realizar las llamadas a la función `ChangeState`, desde los diferentes scripts para que cambie el estado actual. Para eso, vamos a suponer que nos encontramos en el script `NPCIdleState`, que tendrá un cierto código que realizará las distintas acciones del NPC en reposo (gestión de animaciones, sonidos, etc), además del código necesario para poder detectar cuando pasar al siguiente estado. Para hacer esto que acabo de contarte, el script va a necesitar lo siguiente:

 ```c#
 public class NPCIdleState : MonoBehaviour
 {
   ...
   //Aqui habra variables de clase para fines especificos

   void Awake()
   {
     StateMachie = GetComponent<NPCStateMachine>();
   }

   ...
   //Otras funciones especificas

   void checkStartToSpeak()
   {
     StateMachine.ChangeState(NPCTalkState);
   }

   ...
   //Resto de funciones de la clase
 }
 ```

 Así de este modo, conseguiremos que todos los scripts del NPC permanezcan desactivados a excepción del `NPCTalkState` y el `NPCSateMachine`, pasando de esa forma a otra nueva fase de comportamiento. `NPCTalkState` también dispondrá de otro método que llame a `ChangeState` de nuevo para poder acceder a otro estado, creando de ese modo, una cadena de posibles camino además de una simple y básica inteligencia artificial.